<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Document</title>



</head>

<body>
    <script src="https://cdn.jsdelivr.net/npm/noisejs@2.1.0/index.min.js"></script>
    <style>
        * {
            box-sizing: border-box !important;
        }

        body {
            margin: 0 !important;
            padding: 0 !important;
            font-family: 'Segoe UI', sans-serif !important;
            color: white !important;
            background: #ffffff !important;
            overflow-x: hidden !important;
        }

        header {
            text-align: center !important;
            padding: 60px 20px 60px !important;
            position: relative !important;
            z-index: 10 !important;
            background-color: #070709 !important;
        }

        header h1 {
            font-size: 6.5rem !important;
            margin: 0 !important;
            color: #00e5ff !important;
        }

        header p {
            font-size: 3.6rem !important;
            color: #999999 !important;
            margin-top: 20px !important;
            margin-bottom: 20px !important;
            max-width: 600px !important;
            margin-left: auto !important;
            margin-right: auto !important;
        }

        canvas#three {
            position: relative !important;
            display: block !important;
            width: 100% !important;
            height: 1200px !important;
            /* ‚¨ÖÔ∏è AQUI voc√™ ajusta o tamanho do espa√ßo entre header e ui */
            margin: 40px 0 !important;
            /* espa√ßo acima e abaixo (opcional) */
            z-index: 1 !important;
        }

        .ui {
            position: relative !important;
            z-index: 100 !important;
            padding-top: 20px !important;
        }

        .container {
            display: flex !important;
            flex-direction: column !important;
            gap: 100px !important;
            padding: 60px 200px !important;
            max-width: 1100px !important;
            margin: 0 auto !important;
        }

        .box {
            position: relative !important;
            padding: 50px 40px !important;
            font-size: 2rem !important;
            opacity: 0 !important;
            transform: translateX(350px) !important;
            transition: all 2s ease-out !important;
            background: linear-gradient(145deg, #2c3e50, #1c262b) !important;
            color: #fff !important;
            border-radius: 20px !important;
            text-align: center !important;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3) !important;
            border: 1px solid rgba(255, 255, 255, 0.08) !important;
        }

        .box h2 {
            margin: 0 !important;
            font-size: 3rem !important;
            color: #00e5ff !important;
            font-weight: 700 !important;
        }

        .box p {
            margin-top: 15px !important;
            font-size: 1.1rem !important;
            color: #ddd !important;
            letter-spacing: 0.5px !important;
        }

        .box.from-left {
            transform: translateX(-350px) !important;
        }

        .box.show {
            opacity: 1 !important;
            transform: translateX(0) !important;
        }

        footer {
            text-align: center !important;
            color: #666 !important;
            font-size: 0.8rem !important;
            margin-top: 80px !important;
            padding-bottom: 40px !important;
        }

        .cemtec-grid {
            display: flex !important;
            justify-content: center !important;
            flex-direction: column !important;
            width: 941px !important;
            max-width: 941px !important;
            gap: 20px !important;
        }

        .line-grid {
            display: flex !important;
            flex-direction: row !important;
            justify-content: center !important;
            gap: 20px !important;
        }

        .item-info {
            background: #263238 !important;
            color: #fff !important;
            padding: 15px !important;
            border-radius: 12px !important;
            text-align: center !important;
            max-height: 160px !important;
            width: 257px !important;
            max-width: 257px !important;
        }

        .item-info h2 {
            margin: 0px !important;
            font-size: 1.8em !important;
        }

        .item-info p {
            margin: 5px 0 0 !important;
        }

        @media (max-width: 900px) {
            .container {
                padding: 40px !important;
                gap: 80px !important;
            }

            .box h2 {
                font-size: 2.5rem !important;
            }

            .box p {
                font-size: 1rem !important;
            }

            header h1 {
                font-size: 2.5rem !important;
            }
        }

        @media (max-width: 500px) {
            .container {
                padding: 30px 20px !important;
            }

            .box {
                padding: 30px 20px !important;
            }

            .box h2 {
                font-size: 2rem !important;
            }

            .box p {
                font-size: 0.9rem !important;
            }
        }

        table {
            border-collapse: separate !important;
            border-spacing: 0px !important;
        }

        th {
            background-color: #ccc !important;
            border: 1px solid #17252a !important;
            color: #000000 !important;
            min-width: 120px !important;
            font-family: system-ui !important;
            border-radius: 3px !important;
        }

        td {
            background-color: #f0f4f9 !important;
            border: 1px solid #263238 !important;
            color: #000000 !important;
            text-align: center !important;
        }

        #are {}
    </style>
    <header>
        <h1>CEMTEC: Excel√™ncia Comprovada</h1>
        <p>Nossos <strong>resultados robustos</strong> s√£o a <strong>evid√™ncia inquestion√°vel</strong> da nossa
            <strong>efic√°cia superior</strong>.</p>
        <p><strong>N√£o apenas entregamos; n√≥s superamos!</strong></p>
    </header>

    <!-- <canvas id="three-canvas"></canvas> -->

    <div class="ui">


        <h2 style="text-align: center; color: #333; font-weight: 700; margin-bottom: 5px;">
            üî¨ Resultados Acad√™micos
        </h2>
        <p style="text-align: center; color: #777; margin-bottom: 40px;">
            *Os dados apresentados compreendem o per√≠odo entre 2019 e 2024
        </p>

        <div style="display: flex; justify-content: center;">
            <div class="cemtec-grid">
                <div class="line-grid">
                    <div class="item-info">
                        <h2>üìÑ +30</h2>
                        <p>Artigos Cient√≠ficos</p>
                    </div>
                    <div class="item-info">
                        <h2>üåê +35</h2>
                        <p>Participa√ß√µes em congressos</p>
                    </div>
                    <div class="item-info">
                        <h2>üìò 19</h2>
                        <p>Disserta√ß√µes conclu√≠das</p>
                    </div>
                </div>
                <div class="line-grid">
                    <div class="item-info">
                        <h2>üß™ 9</h2>
                        <p>Exames de Qualifica√ß√£o</p>
                    </div>
                    <div class="item-info">
                        <h2>üì® +50</h2>
                        <p>Manifesta√ß√µes do Setor Produtivo</p>
                    </div>
                    <div class="item-info">
                        <h2>üí° 8</h2>
                        <p>Patentes</p>
                    </div>
                </div>
                <div class="line-grid">
                    <div class="item-info">
                        <h2>üéì 23</h2>
                        <p>Trabalhos de Conclus√£o de Curso</p>
                    </div>
                    <div class="item-info">
                        <h2>üìù 10</h2>
                        <p>Relat√≥rios de Ensaio</p>
                    </div>
                    <div class="item-info">
                        <h2>üß† 8</h2>
                        <p>Teses</p>
                    </div>
                </div>
                <div class="line-grid">
                    <div class="item-info">
                        <h2>üèõÔ∏è +120</h2>
                        <p>Atividades Internas</p>
                    </div>
                    <div class="item-info">
                        <h2>üåç +150</h2>
                        <p>Atividades Externas</p>
                    </div>
                </div>
            </div>
        </div>

        <hr style="margin-top: 50px; margin-bottom: 40px; border: none; border-top: 2px solid #ccc;">

        <!-- <button onclick="window.location.href='slider/index.html'">slider</button> -->
        <footer>
            *Dados referentes ao per√≠odo de 2019 a 2024
        </footer>
    </div>



    <h2 style="text-align:center; color:#17252a;">üìä Frequ√™ncia de Uso dos Equipamentos</h2>

    <div id="chartEquipamentos" style="width: 100%; max-width: 1000px; height: 500px; margin: auto;"></div>

    <div style="max-width: 1000px; margin: 30px auto; font-size: 14px; line-height: 1.8; color: #333;">
        <h3 style="color:#17252a; text-align:left;">üìò Equipamentos:</h3>
        <ul style="columns: 2; list-style-type: none; padding-left: 10px; margin: 0;">
            <li><b>SR-800N</b></li>
            <li><b>Corpo Negro</b></li>
            <li><b>Corpo Negro SR-800N-8HT</b></li>
            <li><b>Corpo negro SR-2-33</b></li>
            <li><b>c√©lula TPW</b></li>
            <li><b>Esta√ß√£o Solarim√©trica</b></li>
            <li><b>Forno Fluke 9118A</b></li>
            <li><b>Forno Fluke 9170 / 9172</b></li>
            <li><b>Banho Fluke 7341</b></li>
            <li><b>Termografia Ativa: Laser</b></li>
            <li><b>Termografia Ativa: L√¢mpada</b></li>
            <li><b>Termografia Ativa Flash</b></li>
            <li><b>Termografia Ativa Vibra√ß√£o</b></li>
            <li><b>Termografia Ativa: Solarcheck</b></li>
            <li><b>Termorresist√™ncia : PT100</b></li>
            <li><b>term√¥metro SPRT</b></li>
            <li><b>Termohigr√¥metro Testo 440</b></li>
            <li><b>Sistema de aquisi√ß√£o Fluke 1586A</b></li>
            <li><b>Sistema de aquisi√ß√£o Fluke 1529</b></li>
            <li><b>Termoc√¢mera:T1020, SC660, X6801sc</b></li>
            <li><b>Termohigr√¥metro Testo 622 / 971</b></li>
            <li><b>Tra√ßador de curvas</b></li>
            <li><b>Pir√¥metro</b></li>
            <li><b>Meg√¥metro</b></li>
        </ul>
    </div>

    <!-- Google Charts -->
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>


    <hr style="margin: 30px auto 40px auto; width: 80%; border: none; border-top: 2px solid #ccc;">

    <h3 style="text-align:center; color:#17252a;">üìç Distribui√ß√£o por Finalidade de Uso</h3>

    <!-- √Årea onde o gr√°fico ser√° renderizado -->
    <div id="graficoFinalidadeUso" style="width: 100%; max-width: 800px; height: 450px; margin: 0 auto;"></div>

    <!-- Bot√µes para alternar tipo de gr√°fico (AGORA ABAIXO DO GR√ÅFICO) -->
    <div style="text-align: center; margin: 30px 0 10px 0;">
        <button onclick="tipoGrafico='BarChart'; drawFinalidadeChart();" style="margin-right: 10px;">üìä Barras
            Horizontais</button>
        <button onclick="tipoGrafico='ColumnChart'; drawFinalidadeChart();" style="margin-right: 10px;">üìà Colunas
            Verticais</button>
        <button onclick="tipoGrafico='PieChart'; drawFinalidadeChart();">ü•ß Gr√°fico de Pizza</button>
    </div>

    <div id="tabelaMestra">
        <table>
            <thead>
                <tr>
                    <th id="ano">Ano</th>
                    <th id="tit">T√≠tulo</th>
                    <th id="rev">Revista</th>
                    <th id="aut">Autores</th>
                    <th id="are">√Årea</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    <!-- Google Charts -->
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>

    <script> // utils
        const rgbaToHex = (r, g, b, a = 1, incluirAlpha = false) => {
            const toHex = (c) => {
                let hex = c.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            };

            const red = toHex(Math.min(255, Math.max(0, Math.round(r))));
            const green = toHex(Math.min(255, Math.max(0, Math.round(g))));
            const blue = toHex(Math.min(255, Math.max(0, Math.round(b))));

            let hexString = red + green + blue;

            if (incluirAlpha) {
                const alpha255 = Math.min(255, Math.max(0, Math.round(a * 255)));
                hexString += toHex(alpha255);
            }

            return parseInt(hexString, 16);
        };
    </script>

    <!-- <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script> -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script> -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r149/three.min.js"></script> -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r149/three.min.js"></script> -->

    <script type="module"> // script02
        import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
        // import  Noise  from 'https://cdn.jsdelivr.net/npm/noisejs@2.1.0/index.min.js'; // carregou no html
        // refatorar
        const noise = new Noise(Math.random());

        // animate();

        const scene = new THREE.Scene();
        const height = 881 * 2.3;
        scene.background = new THREE.Color(0x070709);

        const camera = new THREE.PerspectiveCamera(75, innerWidth / height, 0.1, 1000);
        camera.position.z = 15;
        camera.updateProjectionMatrix();

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(innerWidth, height);
        document.body.insertBefore(renderer.domElement, document.querySelector('.ui'));

        const light = new THREE.DirectionalLight(0xffffff, 1.2);
        light.position.set(3, 5, 5);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040, 1));
        var divScroller = 0;
        const propThree2px = 80;
        var propCard = 13;
        var tamCard = propCard * 881 / height; //

        const cards = [];
        const textCard = [
            ["üè¨ +20", "Empresa atendidas com", "solu√ß√µes personalizadas"],
            ["ü§ù 15", "Servi√ßos de alto", "impacto no mercado"],
            ["üíµ +25 Milh√µes", "Em projetos executados", "com nossos parceiros"],
            ["üßæ +50", "Projetos estrat√©gicos", "com o setor privado"],
            ["üìú +65", "Certificados emitidos", "com excel√™ncia t√©cnica"]
        ];
        const images = [
            './data/1.png',
            './data/2.png',
            './data/3.png',
            './data/4.png',
            './data/5.png'
        ];

        function makeCardTexture(text, imageURL) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 512;
            const sizeHeight = size;
            canvas.setAttribute('id', 'three');
            canvas.width = size;
            canvas.height = sizeHeight;

            const loader = new THREE.TextureLoader();
            const texture = new THREE.CanvasTexture(canvas);

            loader.load(imageURL, (imgTex) => {
                ctx.drawImage(imgTex.image, 0, 0, size, size);
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.fillRect(0, 0, size, size);

                ctx.fillStyle = '#00e5ff';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text[0], size / 2, size / 2 - 50);
                ctx.font = 'bold 40px Arial';
                ctx.fillText(text[1], size / 2, size / 2);
                ctx.fillText(text[2], size / 2, size / 2 + 30);

                texture.needsUpdate = true;
            });

            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            return texture;
        }

        for (let i = 0; i < textCard.length; i++) {
            const geo = new THREE.PlaneGeometry(tamCard, tamCard);

            // 1. Material para a FRENTE (Com textura e texto)
            const backMat = new THREE.MeshStandardMaterial({
                map: makeCardTexture(textCard[i], images[i]),
                side: THREE.BackSide, // Renderiza APENAS a face frontal
                roughness: 0.4,
                metalness: 0.1,
                transparent: false,
                opacity: 1
            });
            const backCard = new THREE.Mesh(geo, backMat);

            // 2. Material para as COSTAS (Exemplo: uma cor s√≥lida escura)
            const frontMat = new THREE.MeshStandardMaterial({
                color: 0xffffff, // Cor escura para o verso
                side: THREE.FrontSide, // Renderiza APENAS a face traseira
                roughness: 0.4,
                metalness: 0.1,
                transparent: false,
                opacity: 1
            });
            const frontCard = new THREE.Mesh(geo, frontMat);

            // 3. Cria um grupo para segurar os dois lados
            const cardGroup = new THREE.Group();
            cardGroup.add(backCard);
            cardGroup.add(frontCard);

            // Agora, o array 'cards' armazena o grupo que cont√©m os dois lados
            cards.push(cardGroup);
            scene.add(cardGroup);
        }
        let scroller = 0;
        let t = 0;

        function updateCards(scrollPos) {
            const radius = (propCard / 8) * 5 * 881 / height;
            const spacing = 8 * 881 / height;
            const difY = -0.5; // to down make up, to up make down
            const coe = 1 / 2;
            const padY = 0;

            const altY = 1400;
            const divScrollPos = 0.001;
            divScroller = 0.002;

            t = (altY + scrollPos) * divScrollPos;

            // define um fator de rota√ß√£o extra baseado no scroll
            const downPixels = 330;
            const scrollAngle = (scrollPos / downPixels + 0.35) * Math.PI / 2; // gira 90¬∞ a cada 200px descidos
            // console.log(scrollAngle);

            for (let i = 0; i < cards.length; i++) {
                const card = cards[i];
                const progress = t - i * Math.PI / (40 * height / 881);
                const y = progress * Math.PI - i * spacing;
                const angle = -i * Math.PI * coe + scrollAngle;

                card.rotation.y = Math.PI + scrollAngle;
                card.scale.x = -1;
                card.position.set(
                    Math.cos(angle) * radius,
                    y - difY + padY,
                    Math.sin(angle) * radius
                );
                card.lookAt(0, y - difY + padY, 0);
            }
        }

        window.addEventListener('keydown', (e) => {
            if (e.key === 'w') scroller -= 1;
            if (e.key === 's') scroller += 1;
        });

        function animate() {
            requestAnimationFrame(animate);
            updateCards(window.scrollY);
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / height;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, height);
        });

        document.addEventListener("DOMContentLoaded", () => {
            const boxes = document.querySelectorAll('.box');
            boxes.forEach((box, index) => {
                if (index % 2 === 0) box.classList.add('from-left');
                const observer = new IntersectionObserver(entries => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) entry.target.classList.add('show');
                        else entry.target.classList.remove('show');
                    });
                }, { threshold: 0.3 });
                observer.observe(box);
            });
        });

        function pri(item) {
            console.log(JSON.parse(JSON.stringify(item)));
        }

        // SPHERE

        // mesh final
        var mx = 20, my = 23;

        var spheres = [];
        class Sphere {
            constructor(raio) {
                this.raio = raio;
                this.color = 0xff0000;
                this.colorColisonSphere = 0x0000ff;
                this.dy = 0;

                this.xoff = Math.random() * 100;
                this.yoff = Math.random() * 100;
                this.offs = 0.01 * Math.random();
                this.esferaGeo = new THREE.SphereGeometry(raio, 32, 32);
                this.isColliding = false;

                // material com cor e brilho
                this.esferaMat = new THREE.MeshStandardMaterial({
                    color: 0xaa0000,
                    roughness: 0.3,
                    metalness: 0.25
                });
                this.img = new THREE.Mesh(this.esferaGeo, this.esferaMat);
            }
            log(ind) {
                // paredes
                if (this.img.position.x < -mx * 0.5) this.img.position.x = -mx * 0.5;
                else if (this.img.position.x > mx * 0.5) this.img.position.x = mx * 0.5;

                if (this.img.position.y < -my * 0.5) this.img.position.y = -my * 0.5;
                else if (this.img.position.y > my * 0.5) this.img.position.y = my * 0.5;

                // movimento
                const desloc = 0.03;
                if (window.scrollY != this.dy / divScroller) {
                    this.img.position.y -= this.dy - window.scrollY * divScroller;
                    this.dy = window.scrollY * divScroller;
                }
                this.img.position.y += 0 + noise.perlin2(this.xoff, 0) * desloc;
                this.img.position.x += 0 + noise.perlin2(0, this.yoff) * desloc;
                this.xoff += this.offs;
                this.yoff += this.offs;

                // colis√£o
                let i = -1;
                for (var sphere of spheres) {
                    i++;
                    if (i <= ind) continue;
                    if (sphere != this) {
                        if (this.dist(sphere) < this.raio + sphere.raio) {
                            sphere.colorColisionSphere = this.colorColisonSphere; // neeeeeces√°rio 
                            this.esferaMat.color.set(this.colorColisonSphere);
                            sphere.esferaMat.color.set(sphere.colorColisonSphere);
                            this.isColliding = true;// neeeeeces√°rio
                            sphere.isColliding = true;// neeeeeces√°rio
                        }
                    }
                }
                if (!this.isColliding) this.esferaMat.color.set(this.color);
                this.isColliding = false;
            }
            dist(sphere) {
                var dx = Math.pow(sphere.img.position.x - this.img.position.x, 2);
                var dy = Math.pow(sphere.img.position.y - this.img.position.y, 2);
                return Math.pow(dx + dy, .5);
            }
        }

        class CustomSinCurve extends THREE.Curve {
            constructor(sla, lbs) {
                super(sla);
                this.sx = 0;
                this.sy = 0;
                this.sz = 0;
                this.lambdas = lbs;
            }
            setxyz(x, y, z) {
                this.sx += x;
                this.sy += y;
                this.sz += z;
            }
            getPoint(t, optionalTarget = new THREE.Vector3()) {
                // console.log(t);
                const tx = (t + this.sx) * 2 * this.lambdas - 1.5;
                const ty = Math.sin(2 * Math.PI * (t + this.sy) * this.lambdas);
                const tz = 0;
                return optionalTarget.set(tx, ty, tz);
            }
        }
        class Wave {
            constructor(color, angle, x, y, z) {
                this.angle = angle;
                this.loopLogUp = 0;
                this.img;
                this.raioInterior = 0.05;
                this.color = color;
                this.delta = 0;
                this.delta = -0.004;
                this.mult = 20;
                this.logUp(x, y, z, true);
            }
            log() {

                this.img.position.x += this.delta * this.mult * Math.cos(this.angle);
                this.img.position.y += this.delta * this.mult * Math.sin(this.angle);
                this.path.setxyz(0, this.delta * 2, 0);
                this.loopLogUp++;
                this.interactSpheres();
                this.logUp(0, 0, 0, false);
            }
            logUp(x, y, z, att = false) {

                var poss;
                if (this.loopLogUp > 0) {
                    poss = [this.img.position.x, this.img.position.y, this.img.position.z];
                    // this.img.dispose();
                    scene.remove(this.img);
                    this.geo.dispose();

                } else {
                    this.path = new CustomSinCurve(10, 5);
                    this.mat = new THREE.MeshStandardMaterial({
                        roughness: 1.3,
                        metalness: 0.25,
                        color: this.color
                    });
                }
                this.geo = new THREE.TubeGeometry(this.path, 100, this.raioInterior, 32, false);
                this.img = new THREE.Mesh(this.geo, this.mat);


                if (att) {
                    this.img.position.set(x, y, z);
                }
                this.img.rotation.z = this.angle;

                if (this.loopLogUp > 0) {
                    this.img.position.set(poss[0], poss[1], poss[2]);
                    scene.add(this.img);
                }
            }
            // Dentro da classe Wave

            interactSpheres() {
                // 1. Obtenha os pontos da curva que define o tubo
                // A TubeGeometry √© baseada em uma curva (this.path), que possui um n√∫mero 
                // discreto de pontos ao longo de seu comprimento.
                // O n√∫mero de pontos da curva √© 100 por padr√£o na sua TubeGeometry.
                const curvePoints = this.path.getPoints(100);

                for (var sphere of spheres) {
                    let isColliding = false;

                    // 2. Itera sobre cada ponto da curva
                    for (const curvePoint of curvePoints) {

                        // 3. Aplica a transforma√ß√£o (posi√ß√£o e rota√ß√£o) do mesh da Wave ao ponto da curva.
                        // O ponto da curva est√° em coordenadas locais (relativas √† malha da Wave).
                        // Usamos a matriz de transforma√ß√£o do mesh para obter a posi√ß√£o real (world position) do ponto.
                        const pointWorldPosition = curvePoint.clone();
                        pointWorldPosition.applyMatrix4(this.img.matrixWorld);

                        // 4. Calcula a dist√¢ncia 3D entre a esfera e o ponto real da curva
                        // Usamos a dist√¢ncia 3D, pois a esfera tem profundidade (Z).
                        const distance = pointWorldPosition.distanceTo(sphere.img.position);

                        // 5. Verifica a colis√£o: se a dist√¢ncia for menor que a soma dos raios, houve toque.
                        const collisionThreshold = sphere.raio + this.raioInterior;

                        if (distance < collisionThreshold) {
                            isColliding = true;
                            break; // Encontrou colis√£o, pode parar de checar os outros pontos da curva
                        }
                    }

                    // 6. Atualiza a cor da esfera se houver colis√£o
                    if (isColliding) {
                        sphere.color = this.color;
                    }
                    // Nota: Se voc√™ quiser que a cor "volte" ap√≥s a onda passar, voc√™ precisar√°
                    // armazenar a cor original ou ter uma l√≥gica para limpar a cor ap√≥s um tempo.
                    // A l√≥gica de colis√£o de Sphere vs Sphere (no log da Sphere) j√° trata isso 
                    // ao redefinir para a cor "normal" se n√£o houver colis√£o.
                }
            }
            distSphere(sphere) {
                var dx = Math.pow(sphere.img.position.x - this.img.position.x, 2);
                var dy = Math.pow(sphere.img.position.y - this.img.position.y, 2);
                return Math.pow(dx + dy, .5);
            }
            distCenter() {
                var dx = Math.pow(this.img.position.x, 2);
                var dy = Math.pow(this.img.position.y, 2);
                return Math.pow(dx + dy, .5);
            }
        }

        var teste = new Wave(0x000000, 0);
        var qtSpheres = 70;

        for (let i = 0; i < qtSpheres; i++) {
            var sphere = new Sphere(0.25 / 2);
            sphere.img.position.set(
                (Math.random() - 0.5) * mx,
                (Math.random() - 0.5) * my,
                0
            );
            spheres.push(sphere);
        }
        for (var sphere of spheres) {
            scene.add(sphere.img);
        }

        var waves = [];

        // --- Anima√ß√£o da esfera (movimento + rota√ß√£o) ---
        // Assumindo que 'loop' √© uma vari√°vel global que incrementa a cada frame
        // Assumindo que 'rgbaToHex' √© uma fun√ß√£o auxiliar global (se n√£o estiver definida, isso falhar√°)

        var loop = 0, baseFreq = -0.004 / teste.delta * 400, freq = baseFreq, variFreq = 200; // 200
        var tetoLoop_antiTravamento = 0; // <= 0 to never blocks

        function moverEsfera() {
            // Define o passo (step) para cada transi√ß√£o de cor (ex: 100 frames)
            const step = 50;
            let r = 0, g = 0, b = 0;

            // Calcula a posi√ß√£o atual no ciclo de 6 passos (6 * step frames)
            const cyclePos = loop % (step * 6);

            // Calcula o valor de varia√ß√£o linear dentro do passo atual (0 a 255 ou 255 a 0)
            const value = (cyclePos % step) * (255 / step);

            // --- C√≠rculo Crom√°tico em 6 Fases (RGB -> RGY -> GYB -> YBC -> BCM -> CMR) ---

            // FASE 1: R sobe, G=0, B=0 (Vermelho -> Amarelo)
            if (cyclePos >= 0 * step && cyclePos < 1 * step) {
                r = 255;
                g = value;
                b = 0;
            }
            // FASE 2: R desce, G=255, B=0 (Amarelo -> Verde)
            else if (cyclePos >= 1 * step && cyclePos < 2 * step) {
                r = 255 - value;
                g = 255;
                b = 0;
            }
            // FASE 3: R=0, G=255, B sobe (Verde -> Ciano)
            else if (cyclePos >= 2 * step && cyclePos < 3 * step) {
                r = 0;
                g = 255;
                b = value;
            }
            // FASE 4: R=0, G desce, B=255 (Ciano -> Azul)
            else if (cyclePos >= 3 * step && cyclePos < 4 * step) {
                r = 0;
                g = 255 - value;
                b = 255;
            }
            // FASE 5: R sobe, G=0, B=255 (Azul -> Magenta)
            else if (cyclePos >= 4 * step && cyclePos < 5 * step) {
                r = value;
                g = 0;
                b = 255;
            }
            // FASE 6: R=255, G=0, B desce (Magenta -> Vermelho)
            else if (cyclePos >= 5 * step && cyclePos < 6 * step) {
                r = 255;
                g = 0;
                b = 255 - value;
            }

            // Garante que os valores estejam entre 0 e 255 e sejam inteiros
            r = Math.floor(Math.max(0, Math.min(255, r)));
            g = Math.floor(Math.max(0, Math.min(255, g)));
            b = Math.floor(Math.max(0, Math.min(255, b)));

            // Converte a cor RGB final para Hex (assumindo que rgbaToHex est√° definida)
            const colorCollision = rgbaToHex(r, g, b, 1);

            // Aplica a cor de colis√£o a todas as esferas
            let ind = 0;
            for (var sphere of spheres) {
                // Isso define a cor que a esfera ter√° QUANDO colidir com outra esfera.
                sphere.colorColisonSphere = colorCollision;
                sphere.log(ind);
                ind++;
            }//
            console.log(scene.children.length);
        }

        function logicWaves() {
            // return;
            if (loop % freq == 0) {
                if (waves.length < 3) {
                    let angle = Math.PI / 180 * 360 * Math.random();
                    var wave = new Wave(
                        rgbaToHex(Math.random() * 255, Math.random() * 255, Math.random() * 255, 1, false),
                        angle,
                        Math.cos(angle) * Math.min(mx, my),
                        Math.sin(angle) * Math.min(mx, my),
                        0);
                    waves.push(wave);

                    var inF = Math.floor(Math.random() * variFreq) + baseFreq
                    freq = inF + (inF < freq) ? freq - inF + 1 : 0;
                }
            }
            for (var wave of waves) {
                wave.log();
                if (wave.distCenter() > mx * 2) {
                    let ind = waves.findIndex((x) => x == wave);
                    let a = [], b = [];
                    for (let i = 0; i < ind; i++) {
                        a.push(waves[i]);
                    }
                    for (let i = ind + 1; i < waves.length; i++) {
                        b.push(waves[i]);
                    }
                    waves = a.concat(b);
                    scene.remove(wave.img);
                }
            }
            // console.log(waves.length);

        }

        const mouse = { x: 0, y: 0 };
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / innerWidth) * 2 + 1;
            mouse.y = -(e.clientY / innerHeight) * 2 + 1;
        });

        // adiciona chamada dentro do loop principal de anima√ß√£o:
        const antigoAnimate = animate;
        animate = function () {
            requestAnimationFrame(animate);
            const scroll = window.scrollY;
            // if (videoTexture && video.readyState >= video.HAVE_CURRENT_DATA) {
            //     videoTexture.needsUpdate = true;
            // }
            updateCards(scroll);
            if (loop < tetoLoop_antiTravamento || tetoLoop_antiTravamento <= 0) {
            }
            moverEsfera(); // esfera
            logicWaves();  // waves
            renderer.render(scene, camera);
            loop++;
        };
        //
    </script>


    <script> // dados
        google.charts.load('current', { packages: ['corechart'] });
        google.charts.setOnLoadCallback(() => {
            setTimeout(drawEquipamentosChart, 500);
        });

        function drawEquipamentosChart() {
            const query = new google.visualization.Query('https://docs.google.com/spreadsheets/d/1GjFHo8gTf3WbQhANTKDpcrL3nVUGJCh6Sd7dhoUkn5I/gviz/tq?sheet=Sheet1&headers=1');
            query.setQuery("select I where I is not null");
            query.send(function (response) {
                if (response.isError()) {
                    console.error('Erro ao buscar dados da planilha:', response.getMessage());
                    return;
                }

                const dataTable = response.getDataTable();
                const contagem = {};

                const apelidos = {
                    "SR-800N": "SR-800N",
                    "Corpo Negro": "Corpo Negro",
                    "SR-800N-8HT": "Corpo Negro SR-800N-8HT",
                    "SR-2-33": "Corpo negro SR-2-33",
                    "TPW": "c√©lula TPW",
                    "Solarim√©trica": "Esta√ß√£o Solarim√©trica",
                    "9118A": "Forno Fluke 9118A",
                    "9170": "Forno Fluke 9170 / 9172",
                    "9172": "Forno Fluke 9170 / 9172",
                    "7341": "Banho Fluke 7341",
                    "Laser": "Termografia Ativa: Laser",
                    "L√¢mpada": "Termografia Ativa: L√¢mpada",
                    "Flash": "Termografia Ativa Flash",
                    "Vibra": "Termografia Ativa Vibra√ß√£o",
                    "Solar Check": "Termografia Ativa: Solarcheck",
                    "3450": "Termorresist√™ncia : PT100",
                    "3451": "Termorresist√™ncia : PT100",
                    "SPRT": "term√¥metro SPRT",
                    "440": "Termohigr√¥metro Testo 440",
                    "1586A": "Sistema de aquisi√ß√£o Fluke 1586A",
                    "1529": "Sistema de aquisi√ß√£o Fluke 1529",
                    "T1020": "Termoc√¢mera:T1020, SC660, X6801sc",
                    "SC660": "Termoc√¢mera:T1020, SC660, X6801sc",
                    "X6801sc": "Termoc√¢mera:T1020, SC660, X6801sc",
                    "622": "Termohigr√¥metro Testo 622 / 971",
                    "971": "Termohigr√¥metro Testo 622 / 971",
                    "Tra√ßador": "Tra√ßador de curvas",
                    "Pir√¥metro": "Pir√¥metro",
                    "Meg√¥metro": "Meg√¥metro"
                };

                for (let i = 0; i < dataTable.getNumberOfRows(); i++) {
                    let texto = dataTable.getValue(i, 0);
                    if (!texto) continue;

                    const lista = texto.split(/,|;| e /i);
                    lista.forEach(item => {
                        item = item.replace(/\([^)]*\)/g, '').replace(/CEMTEC\s*/gi, '').trim();
                        if (!item) return;

                        let apelido = "Outros";
                        for (const chave in apelidos) {
                            if (item.toLowerCase().includes(chave.toLowerCase())) {
                                apelido = apelidos[chave];
                                break;
                            }
                        }

                        contagem[apelido] = (contagem[apelido] || 0) + 1;
                    });
                }

                const dados = [['Equipamento', 'Usos']];
                Object.entries(contagem)
                    .sort((a, b) => b[1] - a[1])
                    .forEach(([nome, valor]) => dados.push([nome, valor]));

                const data = google.visualization.arrayToDataTable(dados);

                const options = {
                    title: 'Usos por Equipamento',
                    titleTextStyle: {
                        fontSize: 20,
                        bold: true,
                        color: '#333'
                    },
                    hAxis: {
                        title: 'Equipamento',
                        textStyle: { fontSize: 12 },
                        slantedText: true,
                        slantedTextAngle: 45
                    },
                    vAxis: {
                        title: 'N¬∫ de usos',
                        minValue: 0,
                        gridlines: { count: -1 },
                        textStyle: { fontSize: 12 }
                    },
                    legend: 'none',
                    chartArea: { width: '85%', height: '70%' },
                    colors: ['#00796b']
                };

                const chart = new google.visualization.ColumnChart(document.getElementById('chartEquipamentos'));
                chart.draw(data, options);
            });
        }
    </script>
    <script> // mestra.js
        google.charts.load('current', { packages: ['corechart'] });
        google.charts.setOnLoadCallback(drawFinalidadeChart);

        let tipoGrafico = 'PieChart'; // Valor inicial

        function drawFinalidadeChart() {
            const query = new google.visualization.Query(
                'https://docs.google.com/spreadsheets/d/1GjFHo8gTf3WbQhANTKDpcrL3nVUGJCh6Sd7dhoUkn5I/gviz/tq?sheet=Sheet1&headers=1'
            );
            query.setQuery("select G where G is not null");

            query.send(function (response) {
                if (response.isError()) {
                    console.error('Erro ao buscar dados: ' + response.getMessage());
                    return;
                }

                const dataTable = response.getDataTable();
                const counts = {};

                for (let i = 0; i < dataTable.getNumberOfRows(); i++) {
                    let finalidade = dataTable.getValue(i, 0);
                    if (!finalidade || finalidade === "-") continue;

                    finalidade = finalidade.toLowerCase().trim();

                    // Normaliza√ß√µes e substitui√ß√µes
                    if (finalidade.includes("tesla")) finalidade = "Usina Tesla";
                    if (finalidade.includes("pesquisa")) finalidade = "Pesquisa";
                    if (finalidade.includes("treinamento")) finalidade = "Treinamento";
                    if (finalidade.includes("aula")) finalidade = "Aula Pr√°tica";
                    if (finalidade.includes("ensino")) finalidade = "Ensino";
                    if (finalidade.includes("projeto")) finalidade = "Projeto";
                    if (finalidade.includes("grea")) finalidade = "GREA";
                    if (finalidade.includes("trevizoli")) finalidade = "StreamLab";
                    if (finalidade.includes("cemtec")) finalidade = "CEMTEC";
                    if (finalidade.includes("Cemtec (sala 1906)")) finalidade = "CEMTEC";
                    if (finalidade.includes("O√°sis cad 3")) finalidade = "O√°sis CAD 3";

                    finalidade = finalidade.charAt(0).toUpperCase() + finalidade.slice(1);
                    counts[finalidade] = (counts[finalidade] || 0) + 1;
                }

                const dataArray = [['Finalidade', 'Usos']];
                for (const finalidade in counts) {
                    dataArray.push([finalidade, counts[finalidade]]);
                }

                const data = google.visualization.arrayToDataTable(dataArray);

                const optionsBar = {
                    title: 'Distribui√ß√£o por Finalidade de Uso',
                    chartArea: { width: '75%', height: '80%' },
                    hAxis: { title: 'N¬∫ de usos', minValue: 0, textStyle: { fontSize: 12 } },
                    vAxis: { title: 'Finalidade', textStyle: { fontSize: 12 } },
                    colors: ['#00796b'],
                    legend: 'none'
                };

                const optionsColumn = {
                    title: 'Distribui√ß√£o por Finalidade de Uso',
                    chartArea: { width: '80%', height: '70%' },
                    hAxis: { title: 'Finalidade', slantedText: true, slantedTextAngle: 45, textStyle: { fontSize: 12 } },
                    vAxis: { title: 'N¬∫ de usos', minValue: 0, textStyle: { fontSize: 12 } },
                    colors: ['#42a5f5'],
                    legend: 'none'
                };

                const optionsPie = {
                    title: 'Distribui√ß√£o por Finalidade de Uso',
                    pieHole: 0.4,
                    pieSliceText: 'percentage',
                    legend: { position: 'right', textStyle: { fontSize: 13, color: '#444' } },
                    chartArea: { width: '70%', height: '80%' },
                    colors: ['#ff7043', '#26a69a', '#f4c20d', '#ab47bc', '#42a5f5', '#66bb6a', '#ef5350']
                };

                let chart;
                if (tipoGrafico === 'BarChart') {
                    chart = new google.visualization.BarChart(document.getElementById('graficoFinalidadeUso'));
                    chart.draw(data, optionsBar);
                } else if (tipoGrafico === 'ColumnChart') {
                    chart = new google.visualization.ColumnChart(document.getElementById('graficoFinalidadeUso'));
                    chart.draw(data, optionsColumn);
                } else {
                    chart = new google.visualization.PieChart(document.getElementById('graficoFinalidadeUso'));
                    chart.draw(data, optionsPie);
                }
            });
        }
        // sheets pros trem da planilha "listra mestra"
        const link01 = "https://script.google.com/macros/s/AKfycbzFjyx8CsxJsQcPjQDAi6Qo6NrLzwI-Z-_N0YkfXNdTC8olFC070aXAE7Y0cM7tIFx3/exec";
        const link02 = "https://script.google.com/macros/s/AKfycbzV0d0vb0nfhXmCCsdHp1T6VL7s9tmkLf3FHoBj9EBVH1m3ZIrVoCv3bn2ZeeuauCVneA/exec";
        var link = link02;

        // async function lerJSON() {
        //     print("Lendo Sheets ...");

        //     fetch(link) //link pega sheet
        //         .then(res => res.json())
        //         .then(data => {
        //             print("Dados coletados do Sheets.");
        //             sheets2table(data);
        //             console.log("JSON carregado !");
        //             print("Sheets lido.");
        //         })
        //         .catch(err => console.error('Erro ao carregar JSON:', err));

        //     print("afterrr ...");
        // }

        function sheets2table(datas) {
            var put = [];
            for (var data of datas) {
                var ano = data[0][0];
                if (ano > 2024) continue;
                print(data);
                put.push(data);
            }

            var ord = [];
            for (var i = put.length - 1; i >= 0; i--) {
                ord.push(put[i]);
            }
            put = ord;

            for (var year of put) {
                var body = document.getElementById("tabelaMestra").getElementsByTagName("TBODY")[0];

                ano = year[0][0];

                var i = -1;
                // print(year);

                for (var line of year) {
                    var tr = document.createElement("tr");
                    // print(line);
                    i += 1;
                    if (i == 0) continue;
                    var td = document.createElement("td");
                    td.innerHTML = ano;
                    tr.appendChild(td);
                    for (var item in line) {
                        // print(item);
                        td = document.createElement("td");
                        td.innerHTML = line[item];

                        if (ano == 2019 && item == "") { // atualiza√ß√£o da √°rea em 2019
                            td.innerHTML = "Engenharias III";
                        }
                        if (item == "Observa√ß√µes") { // muda a ordem da apresenta√ß√£o das coisas
                            td.innerHTML = line["Beneficiados do resultado 1"];
                        } else if (item == "Beneficiados do resultado 1") {
                            td.innerHTML = line["Observa√ß√µes"];
                        }

                        tr.appendChild(td);
                    }

                    body.appendChild(tr);
                }
            }
        }

        function print(thing) {
            // return;
            if (thing == null || thing == undefined) console.log(thing);
            else console.log(JSON.parse(JSON.stringify(thing)));
        }
        // lerJSON();
    </script>
</body>

</html>
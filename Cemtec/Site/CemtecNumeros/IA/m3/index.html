<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Espiral 3D com Texto</title>
<style>
  body {
    margin: 0;
    overflow-y: scroll;
    overflow-x: hidden;
    height: 8000px;
    background: #070709;
  }
  canvas {
    position: fixed;
    top: 0;
    left: 0;
    display: block;
  }
</style>
</head>
<body>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';

// --- Cena, câmera e renderizador ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x070709);

const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement); 

// --- Luz ---
scene.add(new THREE.AmbientLight(0xffffff, 1.2));
const dirLight = new THREE.DirectionalLight(0xffffff, 2);
dirLight.position.set(5, 5, 5);
scene.add(dirLight);

// --- Função para criar textura com texto ---
function makeTextTexture(text) {
  const canvas = document.createElement('canvas');
  const size = 512;
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');

  // Fundo e texto
  ctx.fillStyle = '#0d1b2a';
  ctx.fillRect(0, 0, size, size);
  // ctx.fillStyle = '#00e5ff';
  ctx.font = 'bold 60px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, size / 2, size / 2);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  texture.minFilter = THREE.NearestFilter; // desliga suavização
  texture.magFilter = THREE.NearestFilter; // sem blur ao ampliar
  texture.generateMipmaps = false; // evita artefatos
  texture.anisotropy = renderer.capabilities.getMaxAnisotropy(); // melhora ângulos
  return texture;
}

// --- Criar cards com texto ---
const cards = [];
const total = 10;

for (let i = 0; i < total; i++) {
  const geo = new THREE.PlaneGeometry(6, 6);
  const mat = new THREE.MeshStandardMaterial({
    map: makeTextTexture(`Card ${i + 1}`),
    side: THREE.DoubleSide,
    roughness: 0.3,
    metalness: 0.5
  });
  const card = new THREE.Mesh(geo, mat);
  scene.add(card);
  cards.push(card);
}

var propX = 0;
var propY = 0;
var propZ = 0;
var scrollY = 0;

// --- Atualização baseada no scroll ---
function updateCards(scrollPos) {
  const t = (scrollPos+propY/0.5*(10)) * 0.002;
  const radius = 2;
  const spacing = 6;
  console.log(scrollPos);

  for (let i = 0; i < cards.length; i++) {
    const card = cards[i];
    const progress = t - i * 0.5;
    const angle = progress * 1.2;
    const y = progress * 3 - i * spacing;
    card.position.set(Math.cos(angle) * radius, y - 10, Math.sin(angle) * radius);
    card.lookAt(propX,y*1.2-10,propZ);
  }
}

function attP(tecla){
  if (tecla == 'u'){
    propX += 0.5;
  }else if (tecla == 'j'){
    propX -= 0.5;
  }

  if (tecla == 'i'){
    propY += 0.5;
  }else if (tecla == 'k'){
    propY -= 0.5;
  }

  if (tecla == 'o'){
    propZ += 0.5;
  }else if (tecla == 'l'){
    propZ -= 0.5;
  }

}

window.addEventListener('keydown', (event) => {
  const tecla = event.key; // pega a tecla pressionada
  if (/^[a-zA-Z]$/.test(tecla)) { // verifica se é letra
    attP(tecla);
  }
});


// --- Animação ---
function animate() {
  requestAnimationFrame(animate);
  scrollY = window.scrollY;
  updateCards(window.scrollY);
  renderer.render(scene, camera);
}
animate();

// --- Resize ---
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>

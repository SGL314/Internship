<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hero 3D — estilo ActiveTheory</title>
<style>
html, body { height:100%; margin:0; background:#070709; overflow:hidden; font-family:"Segoe UI", monospace; color:#fff; }
canvas { display:block; width:100vw; height:100vh; }
#ui { position:absolute; left:6%; top:10%; z-index:20; pointer-events:none; }
.brand { font-weight:800; font-size:42px; letter-spacing:2px; -webkit-text-stroke:0.6px rgba(0,229,255,0.6);
  background: linear-gradient(90deg,#00e5ff,#fff); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
.sub { margin-top:8px; color:rgba(255,255,255,0.75); font-size:14px; max-width:420px; }
#leftMenu { position:absolute; left:3%; bottom:10%; z-index:20; font-size:12px; color:rgba(255,255,255,0.65); pointer-events:none; line-height:1.8; }
@media (max-width:700px){ .brand{ font-size:28px; } .sub{ font-size:12px; max-width:260px; } }
</style>
</head>
<body>
<div id="container"></div>
<div id="ui">
  <div class="brand">FRONTIER WITHIN</div>
  <div class="sub">A coleção de experimentos, protótipos e interfaces imersivas.</div>
</div>
<div id="leftMenu">
  what are you looking for?<br>
  - websites<br>
  - installations<br>
  - XR / AI<br>
  - multiplayer 
</div>

<script type="module">
    import { OrbitControls } from 'https://unpkg.com/three@0.149.0/examples/jsm/controls/OrbitControls.js';
    import * as THREE from 'https://unpkg.com/three@0.149.0/build/three.module.js';
import { EffectComposer } from 'https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/UnrealBloomPass.js';
import { FilmPass } from 'https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/FilmPass.js';
import { ShaderPass } from 'https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/ShaderPass.js';
import { FXAAShader } from 'https://unpkg.com/three@0.149.0/examples/jsm/shaders/FXAAShader.js';
import { RGBShiftShader } from 'https://unpkg.com/three@0.149.0/examples/jsm/shaders/RGBShiftShader.js';

// ---------- SETUP ----------
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 10);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableRotate = false;
controls.enablePan = false;
controls.enableZoom = false;

// Lights
const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 0.6);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(5,10,7);
scene.add(dir);

// ---------- CARDS HELPER ----------
function roundedCanvasTexture({ w=1024, h=640, radius=40, image=null, title=null }) {
    const cvs = document.createElement('canvas'); cvs.width=w; cvs.height=h;
    const ctx = cvs.getContext('2d', { alpha:true });

    ctx.clearRect(0,0,w,h);
    function roundRectPath(x,y,w,h,r){
        ctx.beginPath();
        ctx.moveTo(x+r,y);
        ctx.arcTo(x+w,y,x+w,y+h,r);
        ctx.arcTo(x+w,y+h,x,y+h,r);
        ctx.arcTo(x,y+h,x,y,r);
        ctx.arcTo(x,y,x+w,y,r);
        ctx.closePath();
    }

    const g = ctx.createLinearGradient(0,0,w,h);
    g.addColorStop(0,'#0b0d10'); g.addColorStop(1,'#111219');
    roundRectPath(0,0,w,h,radius);
    ctx.fillStyle = g; ctx.fill();

    if(image){
        roundRectPath(0,0,w,h,radius); ctx.save(); ctx.clip();
        const ratio = Math.max(w/image.width, h/image.height);
        ctx.drawImage(image,(w-image.width*ratio)/2,(h-image.height*ratio)/2,image.width*ratio,image.height*ratio);
        ctx.restore();
    }

    if(title){
        ctx.save(); ctx.font='bold 64px monospace'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.shadowColor='rgba(0,229,255,0.14)'; ctx.shadowBlur=30;
        ctx.fillStyle='rgba(255,255,255,0.95)';
        const lines = title.split('\n');
        const startY = h/2 - (lines.length-1)*36;
        lines.forEach((line,i)=>ctx.fillText(line,w/2,startY+i*72));
        ctx.restore();
    }

    const tex = new THREE.CanvasTexture(cvs);
    tex.encoding = THREE.sRGBEncoding;
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
    return tex;
}

// ---------- PARTICLES ----------
function makeParticles(){
    const count=2400;
    const geom=new THREE.BufferGeometry();
    const pos=new Float32Array(count*3);
    for(let i=0;i<count;i++){
        pos[i*3]=THREE.MathUtils.randFloatSpread(40);
        pos[i*3+1]=THREE.MathUtils.randFloatSpread(18);
        pos[i*3+2]=THREE.MathUtils.randFloatSpread(120)-40;
    }
    geom.setAttribute('position',new THREE.BufferAttribute(pos,3));
    const sprite=new THREE.Texture(generatePointCanvas()); sprite.needsUpdate=true;
    const mat=new THREE.PointsMaterial({ size:5, map:sprite, transparent:true, depthWrite:false, opacity:0.9, blending:THREE.AdditiveBlending, color:0xffffff });
    const pts=new THREE.Points(geom,mat); pts.position.set(0,-2,-20);
    scene.add(pts); return pts;
}
function generatePointCanvas(){
    const s=64, cvs=document.createElement('canvas'); cvs.width=cvs.height=s;
    const ctx=cvs.getContext('2d');
    const g=ctx.createRadialGradient(s/2,s/2,0,s/2,s/2,s/2);
    g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(0.2,'rgba(255,255,255,0.8)'); g.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle=g; ctx.fillRect(0,0,s,s); return cvs;
}

// ---------- CREATE SCENE ----------
const cards=[];
const sampleImages=[
  'https://images.unsplash.com/photo-1506765515384-028b60a970df?w=1600&q=80&auto=format&fit=crop',
  'https://images.unsplash.com/photo-1518779578993-ec3579fee39f?w=1600&q=80&auto=format&fit=crop',
  'https://images.unsplash.com/photo-1496307042754-b4aa456c4a2d?w=1600&q=80&auto=format&fit=crop',
];

(async function(){
    // main card
    const mainTex = roundedCanvasTexture({ w:1600, h:1000, radius:40, image:null, title:'FRONTIER\nWITHIN' });
    const planeGeo=new THREE.PlaneGeometry(7.2,4.5,32,32);
    const mainMat=new THREE.MeshStandardMaterial({ map:mainTex, transparent:true, roughness:0.7, metalness:0, side:THREE.DoubleSide });
    const mainCard=new THREE.Mesh(planeGeo,mainMat);
    mainCard.position.set(-1.3,0.5,-2); mainCard.rotation.z=-0.06;
    mainCard.userData={ speed:0.6, offset:Math.random()*10 };
    scene.add(mainCard); cards.push(mainCard);

    // small cards
    for(let i=0;i<6;i++){
        try{
            const img=new Image(); img.crossOrigin='anonymous';
            img.src=sampleImages[i%sampleImages.length];
            await img.decode();
            const tex=roundedCanvasTexture({ w:1200,h:800,radius:28,image:img });
            const g=new THREE.PlaneGeometry(3.2,2.05,16,16);
            const m=new THREE.MeshStandardMaterial({ map:tex, transparent:true, roughness:0.7, metalness:0, side:THREE.DoubleSide });
            const mesh=new THREE.Mesh(g,m);
            mesh.position.set( (i%3-1)*4.2 + THREE.MathUtils.randFloatSpread(0.7), (Math.floor(i/3)-0.8)*1.8 + THREE.MathUtils.randFloatSpread(1.1), -6 + i*0.6 );
            mesh.rotation.z = THREE.MathUtils.degToRad(THREE.MathUtils.randFloatSpread(8));
            mesh.rotation.x = THREE.MathUtils.degToRad(THREE.MathUtils.randFloatSpread(6));
            mesh.userData={ speed:0.6+Math.random()*0.8, offset:Math.random()*10 };
            scene.add(mesh); cards.push(mesh);
        } catch(e){ console.warn('img load failed', e); }
    }

    makeParticles();

    // simple sculpture
    const torGeo=new THREE.TorusKnotGeometry(0.8,0.28,120,16);
    const torMat=new THREE.MeshStandardMaterial({ color:0x8fe5ff, roughness:0.25, metalness:0.6, emissive:0x002233, emissiveIntensity:0.2, opacity:0.9, transparent:true });
    const tor=new THREE.Mesh(torGeo,torMat); tor.position.set(2.5,-1.4,-1.8); tor.scale.set(0.9,0.9,0.9);
    scene.add(tor);

    // ---------- POSTPROCESSING ----------
    const composer=new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene,camera));

    const bloomPass=new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight),0.9,0.6,0.85);
    bloomPass.threshold=0; bloomPass.strength=0.9; bloomPass.radius=0.7;
    composer.addPass(bloomPass);

    const rgbPass=new ShaderPass(RGBShiftShader); rgbPass.uniforms['amount'].value=0.0016; composer.addPass(rgbPass);
    const filmPass=new FilmPass(0.35,0.02,648,false); composer.addPass(filmPass);
    const fxaaPass=new ShaderPass(FXAAShader);
    fxaaPass.material.uniforms['resolution'].value.set(1/innerWidth,1/innerHeight);
    composer.addPass(fxaaPass);

    // ---------- ANIMATE ----------
    const clock=new THREE.Clock();
    let mouse={x:0,y:0};
    window.addEventListener('mousemove', e=>{ mouse.x=(e.clientX/innerWidth)*2-1; mouse.y=(e.clientY/innerHeight)*2-1; });

    function onResize(){
        const w=innerWidth, h=innerHeight;
        renderer.setSize(w,h); composer.setSize(w,h);
        camera.aspect=w/h; camera.updateProjectionMatrix();
        fxaaPass.material.uniforms['resolution'].value.set(1/w,1/h);
    }
    window.addEventListener('resize', onResize); onResize();

    const cameraTarget=new THREE.Vector3();
    function animate(){
        requestAnimationFrame(animate);
        const t=clock.getElapsedTime();

        cards.forEach((c,idx)=>{
            const ud=c.userData;
            const baseY=ud.baseY!==undefined?ud.baseY:(ud.baseY=c.position.y);
            c.position.y = baseY + Math.sin(t*ud.speed + ud.offset)*0.25*(0.5+idx*0.02);
            c.rotation.x = Math.sin(t*0.3+ud.offset)*0.04;
            c.rotation.y = THREE.MathUtils.lerp(c.rotation.y, mouse.x*0.12, 0.06);
            c.position.z += Math.sin(t*0.2+ud.offset)*0.002;
        });

        tor.rotation.y += 0.003;
        tor.rotation.x = Math.sin(t*0.15)*0.06;

        cameraTarget.x = THREE.MathUtils.lerp(cameraTarget.x, mouse.x*1.3, 0.06);
        cameraTarget.y = THREE.MathUtils.lerp(cameraTarget.y, -mouse.y*0.8, 0.06);
        camera.position.x = cameraTarget.x; camera.position.y = cameraTarget.y;

        composer.render();
    }
    animate();

})();
</script>
</body>
</html>

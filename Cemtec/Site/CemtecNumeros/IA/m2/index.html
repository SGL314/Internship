<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Espiral 3D Scroll Reveal</title>
<style>
  body {
    margin: 0;
    overflow-y: scroll;
    overflow-x: hidden;
    height: 64000px; /* altura para rolar bastante */
    background: #070709;
  }
  canvas {
    position: fixed;
    top: 0;
    left: 0;
    display: block;
  }
</style>
</head>
<body>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';

// --- Cena, câmera, renderizador ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x070709);

const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.z = 15;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// --- Luz ---
const light = new THREE.DirectionalLight(0xffffff, 1.2);
light.position.set(3, 5, 5);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040, 1));

// --- Criar cards ---
const cards = [];
const total = 5;
const colors = [0xff5733, 0xffbd33, 0x75ff33, 0x33ffbd, 0x3375ff];
for (let i = 0; i < total; i++) {
  const geo = new THREE.PlaneGeometry(8, 8);
  const mat = new THREE.MeshStandardMaterial({
    color: colors[i],
    side: THREE.DoubleSide,
    roughness: 0.4,
    metalness: 0.1,
    transparent: true,
    opacity: 0 // começa invisível
  });
  const card = new THREE.Mesh(geo, mat);
  scene.add(card);
  cards.push(card);
}

var scroller = 0;
var loop = 0;
var loopLastChange = 0;
var lastT = 0,t = 0;
var timeToChange = 100;

// --- Atualização com base no scroll ---
function updateCards(scrollPos) {
  // return;
  lastT = t;
  const altY = 1250, divScrollPos = 0.001,divScroller = 0.002;
  t = (altY+scrollPos) * divScrollPos + scroller*altY*divScroller; // controle de rotação
  if (t != lastT){
    loopLastChange = loop;
  }
  const radius = 5;
  const spacing = 0;
  const difY = 15;
  const coe = 1;    

  for (let i = 0; i < cards.length; i++) {
    const card = cards[i];
    const progress = t - i * 2.5; // controla quando cada card começa
    const visible = true;
    const angle = progress * Math.PI*coe;// gira conforme o scroll
    const y = progress * Math.PI*coe - i * spacing; // sobe suavemente

    if (visible) {
      // card.material.opacity = Math.min(1, progress); // aparece gradualmente
      card.position.set(Math.cos(angle) * radius, y-difY, Math.sin(angle) * radius);
      card.lookAt(0, y-difY, 0);  
      card.material.opacity = 1;
    }
  }
  console.log(scrollPos,t,loopLastChange,loop - loopLastChange >= timeToChange);
  loop++;
  if (loop %60==0){
    if (loop - loopLastChange >= timeToChange){
      var gaps = [3684];
      var adding = 2500;
      for (var i =0 ;i<=total-1;i++){
        gaps[i+1] = gaps[i]+adding;
      }
      const dif = 650;
      for (var gap of gaps){
        if (Math.abs(gap-scrollPos) <= dif){
          console.log(gap);
          scroller = (t-(altY+gap)*divScrollPos)/(altY*divScroller);
          console.log( (altY+scrollPos) * divScrollPos + scroller*altY*divScroller);
          break;
        }
      }
    }
  }
}

// --- Mouse parallax ---
const mouse = { x: 0, y: 0 };
window.addEventListener('mousemove', (e) => {
  mouse.x = (e.clientX / innerWidth - 0.5) * 2;
  mouse.y = (e.clientY / innerHeight - 0.5) * 2;
});


function attP(tecla){
  if (tecla == 'w'){
    scroller -= 1;
  }else if (tecla == 's'){
    scroller += 1;
  }

}

window.addEventListener('keydown', (event) => {
  const tecla = event.key; // pega a tecla pressionada
  if (/^[a-zA-Z]$/.test(tecla)) { // verifica se é letra
    attP(tecla);
  }
});

// --- Animação ---
function animate() {
  requestAnimationFrame(animate);
  const scroll = window.scrollY;
  updateCards(scroll);

  // Parallax suave
  // camera.position.x += (mouse.x * 2 - camera.position.x) * 0.05;
  // camera.position.y += (-mouse.y * 2 - camera.position.y) * 0.05;
  // camera.lookAt(0, 0, 0);

  renderer.render(scene, camera);
}
animate();

// --- Resize ---
window.addEventListener('resize', () => {
  // camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Espiral 3D Scroll Reveal</title>
<style>
  body {
    margin: 0;
    overflow-y: scroll;
    overflow-x: hidden;
    height: 4000px; /* altura para rolar bastante */
    background: #070709;
  }
  canvas {
    position: fixed;
    top: 0;
    left: 0;
    display: block;
  }
</style>
</head>
<body>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';

// --- Cena, câmera, renderizador ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x070709);

const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.z = 15;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// --- Luz ---
const light = new THREE.DirectionalLight(0xffffff, 1.2);
light.position.set(3, 5, 5);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040, 1));

// --- Criar cards ---
const cards = [];
const total = 10;
for (let i = 0; i < total; i++) {
  const geo = new THREE.PlaneGeometry(3, 2);
  const mat = new THREE.MeshStandardMaterial({
    color: 0x00e5ff,
    side: THREE.DoubleSide,
    roughness: 0.4,
    metalness: 0.1,
    transparent: true,
    opacity: 0 // começa invisível
  });
  const card = new THREE.Mesh(geo, mat);
  scene.add(card);
  cards.push(card);
}

// --- Atualização com base no scroll ---
function updateCards(scrollPos) {
  const t = scrollPos * 0.002; // controle de rotação
  const radius = 5;
  const spacing = 3;

  for (let i = 0; i < cards.length; i++) {
    const card = cards[i];
    const progress = t - i * 0.5; // controla quando cada card começa
    const visible = true;
    const angle = progress * 1.2; // gira conforme o scroll
    const y = progress * 3 - i * spacing; // sobe suavemente

    if (visible) {
      // card.material.opacity = Math.min(1, progress); // aparece gradualmente
      card.position.set(Math.cos(angle) * radius, y-10, Math.sin(angle) * radius);
      card.lookAt(0, y-10, 0);  
      card.material.opacity = 1;
    }
  }
}

// --- Mouse parallax ---
const mouse = { x: 0, y: 0 };
window.addEventListener('mousemove', (e) => {
  mouse.x = (e.clientX / innerWidth - 0.5) * 2;
  mouse.y = (e.clientY / innerHeight - 0.5) * 2;
});

// --- Animação ---
function animate() {
  requestAnimationFrame(animate);
  const scroll = window.scrollY;
  updateCards(scroll);

  // Parallax suave
  // camera.position.x += (mouse.x * 2 - camera.position.x) * 0.05;
  // camera.position.y += (-mouse.y * 2 - camera.position.y) * 0.05;
  // camera.lookAt(0, 0, 0);

  renderer.render(scene, camera);
}
animate();

// --- Resize ---
window.addEventListener('resize', () => {
  // camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>

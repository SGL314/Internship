<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>

  <style>
    * {
      box-sizing: border-box;
    }

    /* spiral */
    #spiral {
      margin: 0;
      overflow-y: scroll;
      overflow-x: hidden;
      height: 15300px;
      /* altura para rolar bastante */
      background: #070709;
      z-index: 0;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      display: block;
      z-index: 0;
    }

    .ui {
      height: 5000px;
      z-index: 10;
    }

    /*  */


    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', sans-serif;
      /* background: #12181c;    */
      color: white;
    }

    header {
      text-align: center;
      padding: 100px 20px 60px;
    }

    header h1 {
      font-size: 3.5rem;
      margin: 0;
      color: #00e5ff;
    }

    header p {
      font-size: 1.2rem;
      color: #999999;
      margin-top: 20px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    .cta-button {
      margin-top: 40px;
      padding: 15px 35px;
      font-size: 1rem;
      font-weight: bold;
      color: #fff;
      background: #00e5ff;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .cta-button:hover {
      background: #00bcd4;
    }

    .container {
      display: flex;
      flex-direction: column;
      gap: 100px;
      padding: 60px 200px;
      max-width: 1100px;
      margin: 0 auto;
    }

    .box {
      position: relative;
      padding: 50px 40px;
      font-size: 2rem;
      opacity: 0;
      transform: translateX(350px);
      transition: all 2s ease-out;
      background: linear-gradient(145deg, #2c3e50, #1c262b);
      color: #fff;
      border-radius: 20px;
      text-align: center;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(4px);
    }

    .box h2 {
      margin: 0;
      font-size: 3rem;
      color: #00e5ff;
      font-weight: 700;
    }

    .box p {
      margin-top: 15px;
      font-size: 1.1rem;
      color: #ddd;
      letter-spacing: 0.5px;
    }

    .item-info {
      background: #263238;
      color: #fff;
      padding: 15px;
      border-radius: 12px;
      text-align: center;
      max-height: 160px;
      width: 257px;
      max-width: 257px;
      /* gap: 20px; */
    }

    .item-info h2 {
      margin: 0px;
      font-size: 1.8em;
    }

    .item-info p {
      margin: 5px 0 0;
    }

    .box.from-left {
      transform: translateX(-350px);
    }

    .box.show {
      opacity: 1;
      transform: translateX(0);
    }

    footer {
      text-align: center;
      color: #666;
      font-size: 0.8rem;
      margin-top: 80px;
      padding-bottom: 40px;
    }

    @media (max-width: 900px) {
      .container {
        padding: 40px;
        gap: 80px;
      }

      .box h2 {
        font-size: 2.5rem;
      }

      .box p {
        font-size: 1rem;
      }

      header h1 {
        font-size: 2.5rem;
      }
    }

    @media (max-width: 500px) {
      .container {
        padding: 30px 20px;
      }

      .box {
        padding: 30px 20px;
      }

      .box h2 {
        font-size: 2rem;
      }

      .box p {
        font-size: 0.9rem;
      }
    }

    .cemtec-grid {
      display: flex;
      justify-content: center;
      flex-direction: column;
      width: 941px;
      max-width: 941px;
      gap: 20px;
      /* margin-bottom: 20px; */
      /* grid-template-columns: repeat(3, 1fr); */
      /* gap: 20px; */
    }

    .line-grid {
      display: flex;
      flex-direction: row;
      justify-content: center;
      gap: 20px;
      /* margin: 40px; */
    }
  </style>
  <script>
    const boxes = document.querySelectorAll('.box');

    boxes.forEach((box, index) => {
      if (index % 2 === 0) {
        box.classList.add('from-left');
      }

      const observer = new IntersectionObserver(
        entries => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              entry.target.classList.add('show');
            } else {
              entry.target.classList.remove('show');
            }
          });
        },
        {
          threshold: 0.3
        }
      );

      observer.observe(box);
    });
  </script>
  <!-- <script type="module"> -->
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';

    // --- Cena, c√¢mera, renderizador ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x070709);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
    camera.position.z = 15;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- Luz ---
    const light = new THREE.DirectionalLight(0xffffff, 1.2);
    light.position.set(3, 5, 5);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040, 1));

    // --- Criar cards ---

    var cards = [];
    const total = 5;
    const images = [
      './1.png',
      './2.png',
      './3.png',
      './4.png',
      './5.png'
    ];
    var video,videoTexture;

    for (let i = 0; i < total; i++) {
      if (i == -1){ // video -> n√£o usual
        // cria o elemento de v√≠deo
        video = document.createElement('video');
        video.src = 'a.mp4';
        video.loop = true;
        video.muted = true;       // ‚ö† autoplay exige mutado
        video.autoplay = true;
        video.playsInline = true; // importante no mobile
        video.style.display = 'none';
        document.body.appendChild(video); // precisa estar no DOM

        // s√≥ criar a textura quando o v√≠deo estiver pronto
        video.addEventListener('loadeddata', () => {
          videoTexture = new THREE.VideoTexture(video);
          videoTexture.minFilter = THREE.LinearFilter;
          videoTexture.magFilter = THREE.LinearFilter;
          videoTexture.format = THREE.RGBAFormat;

          const mat = new THREE.MeshStandardMaterial({
              map: videoTexture,
              side: THREE.DoubleSide,roughness: 0.4,
              metalness: 0.1,
              transparent: true,
              opacity: 1
          });

          const geo = new THREE.PlaneGeometry(8, 8);
          const card = new THREE.Mesh(geo, mat);
          scene.add(card);
          // cards.push(card);

          video.play(); // ‚ö° come√ßa a tocar

          
        });
        
        // continue;

        // // cria textura a partir do v√≠deo
        // const videoTexture = new THREE.VideoTexture(video);
        // videoTexture.minFilter = THREE.LinearFilter;
        // videoTexture.magFilter = THREE.LinearFilter;
        // videoTexture.format = THREE.RGBFormat;

        // // taka o texto
        // const size = 512;
        // const canvas = document.createElement('canvas');
        // const ctx = canvas.getContext('2d');
        // ctx.fillStyle = 'rgba(0,0,0,0.4)';
        // ctx.fillRect(0, 0, size, size);
        // ctx.fillStyle = '#00e5ff';
        // ctx.font = 'bold 48px Arial';
        // ctx.textAlign = 'center';
        // ctx.textBaseline = 'middle';
        // ctx.fillText(`Card ${i + 1}`, size / 2, size / 2);
        // videoTexture.needsUpdate = true;

        // // cria o card com o v√≠deo
        // const geometry = new THREE.PlaneGeometry(6, 4);
        // const material = new THREE.MeshStandardMaterial({
        //   map: videoTexture,
        //   side: THREE.DoubleSide
        // });

        // const videoCard = new THREE.Mesh(geometry, material);
        // scene.add(videoCard);
        // cards.push(videoCard);
        // videoCard.position.z = -5;
      }else{
        const geo = new THREE.PlaneGeometry(8, 8);

        // üëâ Aqui √© onde chama a fun√ß√£o
        const texture = makeCardTexture(`Card ${i + 1}`, images[i]);
        const mat = new THREE.MeshStandardMaterial({
          map: texture,
          side: THREE.DoubleSide,
          roughness: 0.4,
          metalness: 0.1,
          transparent: true,
          opacity: 1,
          name: `card${i+1}`
        });
        const card = new THREE.Mesh(geo, mat);
        cards.push(card);
        scene.add(card);
      }
    }

    pri(cards);
    var scroller = 0;
    var t=0;
    var loop = 0;
    var loopLastChange = 0;
    var lastT = 0,t = 0;
    var timeToChange = 100;

    // --- Atualiza√ß√£o com base no scroll ---
    function updateCards(scrollPos) {
      // return;
      lastT = t;
      const altY = 1250, divScrollPos = 0.001,divScroller = 0.002;
      t = (altY+scrollPos) * divScrollPos + scroller*altY*divScroller; // controle de rota√ß√£o
      if (t != lastT){
        loopLastChange = loop;
      }
      const radius = 5;
      const spacing = 0;
      const difY = 15;
      const coe = 1; 
        
      var appr = 0;
      for (let i = 0; i < cards.length; i++) {
        const card = cards[i];
        const progress = t - i * 2.5; // controla quando cada card come√ßa
        const visible = true;
        const angle = progress * Math.PI*coe;// gira conforme o scroll
        const y = progress * Math.PI*coe - i * spacing; // sobe suavemente
        card.rotation.y = Math.PI;
        card.scale.x = -1;

        if (visible) {
          // card.material.opacity = Math.min(1, progress); // aparece gradualmente
          card.position.set(Math.cos(angle) * radius, y-difY, Math.sin(angle) * radius);
          card.lookAt(0, y-difY, 0);  
          card.material.opacity = 1;
        }
        appr ++;
      }
      pri(appr);
      console.log(scrollPos,t,loopLastChange,loop - loopLastChange >= timeToChange);
      loop++;
      if (loop %60==0 && false){
        if (loop - loopLastChange >= timeToChange){
          var gaps = [3684];
          var adding = 2500;
          for (var i =0 ;i<=total-1;i++){
            gaps[i+1] = gaps[i]+adding;
          }
          const dif = 650;
          for (var gap of gaps){
            if (Math.abs(gap-scrollPos) <= dif){
              console.log(gap);
              scroller = (t-(altY+gap)*divScrollPos)/(altY*divScroller);
              console.log( (altY+scrollPos) * divScrollPos + scroller*altY*divScroller);
              break;
            }
          }
        }
      }
    }

    // --- Mouse parallax ---
    const mouse = { x: 0, y: 0 };
    window.addEventListener('mousemove', (e) => {
      mouse.x = (e.clientX / innerWidth - 0.5) * 2;
      mouse.y = (e.clientY / innerHeight - 0.5) * 2;
    });


    function attP(tecla){
      if (tecla == 'w'){
        scroller -= 1;
      }else if (tecla == 's'){
        scroller += 1;
      }

    }

    window.addEventListener('keydown', (event) => {
      const tecla = event.key; // pega a tecla pressionada
      if (/^[a-zA-Z]$/.test(tecla)) { // verifica se √© letra
        attP(tecla);
      }
    });

    // --- Anima√ß√£o ---
    function animate() {
      requestAnimationFrame(animate);
      const scroll = window.scrollY;
      if (videoTexture && video.readyState >= video.HAVE_CURRENT_DATA) {
        videoTexture.needsUpdate = true;
      }
      updateCards(scroll);

      // Parallax suave
      // camera.position.x += (mouse.x * 2 - camera.position.x) * 0.05;
      // camera.position.y += (-mouse.y * 2 - camera.position.y) * 0.05;
      // camera.lookAt(0, 0, 0);

      renderer.render(scene, camera);
    }
    animate();

    // --- Resize ---
    window.addEventListener('resize', () => {
      // camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // image & text
    // --- Fun√ß√£o para gerar textura com imagem + texto ---
    // --- Fun√ß√£o para gerar textura com imagem + texto (corrigida) ---
    function makeCardTexture(text, imageURL) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const size = 512;
      canvas.width = size;
      canvas.height = size;

      // Carrega a imagem com THREE.TextureLoader
      const loader = new THREE.TextureLoader();
      const texture = new THREE.CanvasTexture(canvas);

      loader.load(
        imageURL,
        (imageTex) => {
          const img = imageTex.image;
          ctx.drawImage(img, 0, 0, size, size);

          // Sobreposi√ß√£o escura pra legibilidade
          ctx.fillStyle = 'rgba(0,0,0,0.4)';
          ctx.fillRect(0, 0, size, size);

          // Texto centralizado
          ctx.fillStyle = '#00e5ff';
          ctx.font = 'bold 48px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(text, size / 2, size / 2);

          texture.needsUpdate = true; // üîπ for√ßa atualiza√ß√£o no WebGL
        },
        undefined,
        (err) => console.error('Erro ao carregar imagem:', imageURL, err)
      );

      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      return texture;
    }


    function pri(item){
      console.log(JSON.parse(JSON.stringify(item)))
    }

  </script>
<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';

    // --- Cena, c√¢mera, renderizador ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x070709);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
    camera.position.z = 15;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.getElementById("spiral").appendChild(renderer.domElement);

    // --- Luz ---
    const light = new THREE.DirectionalLight(0xffffff, 1.2);
    light.position.set(3, 5, 5);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040, 1));

    // --- Criar cards ---

    var cards = [];
    const textCard = [["üè¨ +20","Empresa atendidas","com solu√ß√µes personalizadas"],
        ["ü§ù 15","Servi√ßos de alto","impacto no mercado"],
        ["üíµ +25 Milh√µes","Em projetos executados","com nossos parceiros"],
      ["üßæ +50","Projetos estrat√©gicos","com o setor privado"],
        ["üìú +65","Certificados emitidos","com excel√™ncia t√©cnica"]
    ];
    const total = 5;
    const images = [
      './data/1.png',
      './data/2.png',
      './data/3.png',
      './data/4.png',
      './data/5.png'
    ];
    var video,videoTexture;

    for (let i = 0; i < total; i++) {
      if (i == -1){ // video -> n√£o usual
        // cria o elemento de v√≠deo
        video = document.createElement('video');
        video.src = 'a.mp4';
        video.loop = true;
        video.muted = true;       // ‚ö† autoplay exige mutado
        video.autoplay = true;
        video.playsInline = true; // importante no mobile
        video.style.display = 'none';
        document.getElementById("spiral").appendChild(video); // precisa estar no DOM

        // s√≥ criar a textura quando o v√≠deo estiver pronto
        video.addEventListener('loadeddata', () => {
          videoTexture = new THREE.VideoTexture(video);
          videoTexture.minFilter = THREE.LinearFilter;
          videoTexture.magFilter = THREE.LinearFilter;
          videoTexture.format = THREE.RGBAFormat;

          const mat = new THREE.MeshStandardMaterial({
              map: videoTexture,
              side: THREE.DoubleSide,roughness: 0.4,
              metalness: 0.1,
              transparent: true,
              opacity: 1
          });

          const geo = new THREE.PlaneGeometry(8, 8);
          const card = new THREE.Mesh(geo, mat);
          scene.add(card);
          // cards.push(card);

          video.play(); // ‚ö° come√ßa a tocar

          
        });
        
        // continue;

        

        // // cria textura a partir do v√≠deo
        // const videoTexture = new THREE.VideoTexture(video);
        // videoTexture.minFilter = THREE.LinearFilter;
        // videoTexture.magFilter = THREE.LinearFilter;
        // videoTexture.format = THREE.RGBFormat;

        // // taka o texto
        // const size = 512;
        // const canvas = document.createElement('canvas');
        // const ctx = canvas.getContext('2d');
        // ctx.fillStyle = 'rgba(0,0,0,0.4)';
        // ctx.fillRect(0, 0, size, size);
        // ctx.fillStyle = '#00e5ff';
        // ctx.font = 'bold 48px Arial';
        // ctx.textAlign = 'center';
        // ctx.textBaseline = 'middle';
        // ctx.fillText(`Card ${i + 1}`, size / 2, size / 2);
        // videoTexture.needsUpdate = true;

        // // cria o card com o v√≠deo
        // const geometry = new THREE.PlaneGeometry(6, 4);
        // const material = new THREE.MeshStandardMaterial({
        //   map: videoTexture,
        //   side: THREE.DoubleSide
        // });

        // const videoCard = new THREE.Mesh(geometry, material);
        // scene.add(videoCard);
        // cards.push(videoCard);
        // videoCard.position.z = -5;
      }else{
        const geo = new THREE.PlaneGeometry(8, 8);

        // üëâ Aqui √© onde chama a fun√ß√£o
        const texture = makeCardTexture(textCard[i], images[i]);
        const mat = new THREE.MeshStandardMaterial({
          map: texture,
          side: THREE.DoubleSide,
          roughness: 0.4,
          metalness: 0.1,
          transparent: true,
          opacity: 1,
          name: `card${i+1}`
        });
        const card = new THREE.Mesh(geo, mat);
        cards.push(card);
        scene.add(card);
      }
    }

    pri(cards);

    var scroller = 0;
    var t=0;
    var loop = 0;
    var loopLastChange = 0;
    var lastT = 0,t = 0;
    var timeToChange = 100;

    // --- Atualiza√ß√£o com base no scroll ---
    const altY = 1250, divScrollPos = 0.001,divScroller = 0.002;
    function updateCards(scrollPos) {
      // return;
      lastT = t;
      t = (altY+scrollPos) * divScrollPos + scroller*altY*divScroller; // controle de rota√ß√£o
      if (t != lastT){
        loopLastChange = loop;
      }
      const radius = 5;
      const spacing = 0;
      const difY = 15;
      const coe = 1/2; 
        
      var appr = 0;
      for (let i = 0; i < cards.length; i++) {
        const card = cards[i];
        const progress = t - i*Math.PI/2 +3; // controla quando cada card come√ßa
        const visible = true;
        const angle = -i*Math.PI*coe+t;// gira conforme o scroll
        const y = progress * Math.PI - i * spacing; // sobe suavemente
        card.rotation.y = Math.PI;
        card.scale.x = -1;

        if (visible) {
          // card.material.opacity = Math.min(1, progress); // aparece gradualmente
          card.position.set(Math.cos(angle) * radius, y-difY, Math.sin(angle) * radius);
          card.lookAt(0, y-difY, 0);  
          card.material.opacity = 1;
        }
        appr ++;
      }
      // pri(appr);
      // console.log(scrollPos,t,loopLastChange,loop - loopLastChange >= timeToChange);
      loop++;
      if (loop %60==0 && false){
        if (loop - loopLastChange >= timeToChange){
          var gaps = [3684];
          var adding = 2500;
          for (var i =0 ;i<=total-1;i++){
            gaps[i+1] = gaps[i]+adding;
          }
          const dif = 650;
          for (var gap of gaps){
            if (Math.abs(gap-scrollPos) <= dif){
              // console.log(gap);
              scroller = (t-(altY+gap)*divScrollPos)/(altY*divScroller);
              // console.log( (altY+scrollPos) * divScrollPos + scroller*altY*divScroller);
              break;
            }
          }
        }
      }
    }

    // --- Mouse parallax ---
    const mouse = { x: 0, y: 0 };
    window.addEventListener('mousemove', (e) => {
      mouse.x = (e.clientX / innerWidth) * 2+1;
      mouse.y = -(e.clientY / innerHeight) * 2+1;
    });


    function attP(tecla){
      // if (tecla == 'w'){
      //   scroller -= 1;
      // }else if (tecla == 's'){
      //   scroller += 1;
      // }

    }

    window.addEventListener('keydown', (event) => {
      const tecla = event.key; // pega a tecla pressionada
      if (/^[a-zA-Z]$/.test(tecla)) { // verifica se √© letra
        attP(tecla);
      }
    });

    // --- Anima√ß√£o ---
    function animate() {
      requestAnimationFrame(animate);
      const scroll = window.scrollY;
      if (videoTexture && video.readyState >= video.HAVE_CURRENT_DATA) {
        videoTexture.needsUpdate = true;
      }
      updateCards(scroll);

      // Parallax suave
      // camera.position.x += (mouse.x * 2 - camera.position.x) * 0.05;
      // camera.position.y += (-mouse.y * 2 - camera.position.y) * 0.05;
      // camera.lookAt(0, 0, 0);

      renderer.render(scene, camera);
    }
    animate();

    // --- Resize ---
    window.addEventListener('resize', () => {
      // camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // image & text
    // --- Fun√ß√£o para gerar textura com imagem + texto ---
    // --- Fun√ß√£o para gerar textura com imagem + texto (corrigida) ---
    function makeCardTexture(text, imageURL) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const size = 512;
      canvas.width = size;
      canvas.height = size;

      // Carrega a imagem com THREE.TextureLoader
      const loader = new THREE.TextureLoader();
      const texture = new THREE.CanvasTexture(canvas);

      loader.load(
        imageURL,
        (imageTex) => {
          const img = imageTex.image;
          ctx.drawImage(img, 0, 0, size, size);

          // Sobreposi√ß√£o escura pra legibilidade
          ctx.fillStyle = 'rgba(0,0,0,0.4)';
          ctx.fillRect(0, 0, size, size);

          // Texto centralizado 
          ctx.fillStyle = '#00e5ff';
          ctx.font = 'bold 36px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(text[0], size / 2, size / 2-50);
          ctx.font = 'bold 24px Arial';
          ctx.fillText(text[1], size / 2, size / 2);
          ctx.fillText(text[2], size / 2, size / 2+30);

          texture.needsUpdate = true; // üîπ for√ßa atualiza√ß√£o no WebGL
        },
        undefined,
        (err) => console.error('Erro ao carregar imagem:', imageURL, err)
      );

      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      return texture;
    }


    function pri(item){
      console.log(JSON.parse(JSON.stringify(item)))
    }

    // --- Criar uma esfera ---
    // geometria (raio, segmentos horizontais, verticais)
    

    // mesh final
    class Sphere{
      constructor(raio ){
        this.raio = raio;
        this.dy = 0;
        this.esferaGeo = new THREE.SphereGeometry(raio, 32, 32);

        // material com cor e brilho
        this.esferaMat = new THREE.MeshStandardMaterial({
          color: 0xaa0000,
          roughness: 0.3,
          metalness: 0.1
        });
        this.img = new THREE.Mesh(this.esferaGeo, this.esferaMat);
      }
    }
    var spheres = [];
    for (let i =0;i<500;i++){
      var sphere = new Sphere(0.25);
      sphere.img.position.set(
        (Math.random()-0.5)*40,
        (Math.random()-0.5)*200,
        0
      );
      spheres.push(sphere);
    }
    for (var sphere of spheres){
      scene.add(sphere.img);
      pri(sphere.img);
    }

    // --- Anima√ß√£o da esfera (movimento + rota√ß√£o) ---
    function moverEsfera() {
      // movimento senoidal no eixo Y
      console.log(spheres[0].dy,window.scrollY);
      for (var sphere of spheres){
        const desloc = 0.03;
        if (window.scrollY != sphere.dy/divScroller){
          sphere.img.position.y -= sphere.dy-window.scrollY*divScroller;
          sphere.dy = window.scrollY*divScroller;
        }
        sphere.img.position.y += (Math.random()*2-1)*desloc;
        sphere.img.position.x += (Math.random()*2-1)*desloc;

        sphere.img.rotation.x += 0.01;
        sphere.img.rotation.y += 0.02;

        if (Math.pow(Math.pow(sphere.img.position.x-mouse.x,2)+Math.pow(sphere.img.position.y-mouse.y,2),.5) < 1){ // dif mouse and sphere
          sphere.esferaMat.color.set(0x0000aa);
          
          pri("dentro");
        }else{
          sphere.esferaMat.color.set(0xaa0000);
        }
      }

    }

    // adiciona chamada dentro do loop principal de anima√ß√£o:
    const antigoAnimate = animate;
    animate = function() {
      requestAnimationFrame(animate);
      const scroll = window.scrollY;
      if (videoTexture && video.readyState >= video.HAVE_CURRENT_DATA) {
        videoTexture.needsUpdate = true;
      }
      updateCards(scroll);
      moverEsfera(); // üëà atualiza a esfera aqui
      renderer.render(scene, camera);
    };


window.addEventListener('keydown', (event) => {
  const tecla = event.key; // pega a tecla pressionada
  if (/^[a-zA-Z]$/.test(tecla)) { // verifica se √© letra
    attP(tecla);
  }
});

// --- Anima√ß√£o ---
function animate() {
  requestAnimationFrame(animate);
  const scroll = window.scrollY;
  if (videoTexture && video.readyState >= video.HAVE_CURRENT_DATA) {
    videoTexture.needsUpdate = true;
  }
  updateCards(scroll);

  // Parallax suave
  // camera.position.x += (mouse.x * 2 - camera.position.x) * 0.05;
  // camera.position.y += (-mouse.y * 2 - camera.position.y) * 0.05;
  // camera.lookAt(0, 0, 0);

  renderer.render(scene, camera);
}
animate();

// --- Resize ---
window.addEventListener('resize', () => {
  // camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// image & text
// --- Fun√ß√£o para gerar textura com imagem + texto ---
// --- Fun√ß√£o para gerar textura com imagem + texto (corrigida) ---
function makeCardTexture(text, imageURL) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const size = 512;
  canvas.width = size;
  canvas.height = size;

  // Carrega a imagem com THREE.TextureLoader
  const loader = new THREE.TextureLoader();
  const texture = new THREE.CanvasTexture(canvas);

  loader.load(
    imageURL,
    (imageTex) => {
      const img = imageTex.image;
      ctx.drawImage(img, 0, 0, size, size);

      // Sobreposi√ß√£o escura pra legibilidade
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.fillRect(0, 0, size, size);

      // Texto centralizado
      ctx.fillStyle = '#00e5ff';
      ctx.font = 'bold 48px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, size / 2, size / 2);

      texture.needsUpdate = true; // üîπ for√ßa atualiza√ß√£o no WebGL
    },
    undefined,
    (err) => console.error('Erro ao carregar imagem:', imageURL, err)
  );

  texture.minFilter = THREE.LinearFilter;
  texture.magFilter = THREE.LinearFilter;
  return texture;
}


function pri(item){
  console.log(JSON.parse(JSON.stringify(item)))
}

  </script> -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';

    // --- Cena, c√¢mera, renderizador ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x070709);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
    camera.position.z = 15;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.getElementById("spiral").appendChild(renderer.domElement);

    // --- Luz ---
    const light = new THREE.DirectionalLight(0xffffff, 1.2);
    light.position.set(3, 5, 5);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040, 1));

    // --- Criar cards ---

    var cards = [];
    const textCard = [["üè¨ +20", "Empresa atendidas", "com solu√ß√µes personalizadas"],
    ["ü§ù 15", "Servi√ßos de alto", "impacto no mercado"],
    ["üíµ +25 Milh√µes", "Em projetos executados", "com nossos parceiros"],
    ["üßæ +50", "Projetos estrat√©gicos", "com o setor privado"],
    ["üìú +65", "Certificados emitidos", "com excel√™ncia t√©cnica"]
    ];
    const total = 5;
    const images = [
      './data/1.png',
      './data/2.png',
      './data/3.png',
      './data/4.png',
      './data/5.png'
    ];
    var video, videoTexture;

    for (let i = 0; i < total; i++) {
      if (i == -1) { // video -> n√£o usual
        // cria o elemento de v√≠deo
        video = document.createElement('video');
        video.src = 'a.mp4';
        video.loop = true;
        video.muted = true;       // ‚ö† autoplay exige mutado
        video.autoplay = true;
        video.playsInline = true; // importante no mobile
        video.style.display = 'none';
        document.getElementById("spiral").appendChild(video); // precisa estar no DOM

        // s√≥ criar a textura quando o v√≠deo estiver pronto
        video.addEventListener('loadeddata', () => {
          videoTexture = new THREE.VideoTexture(video);
          videoTexture.minFilter = THREE.LinearFilter;
          videoTexture.magFilter = THREE.LinearFilter;
          videoTexture.format = THREE.RGBAFormat;

          const mat = new THREE.MeshStandardMaterial({
            map: videoTexture,
            side: THREE.DoubleSide, roughness: 0.4,
            metalness: 0.1,
            transparent: true,
            opacity: 1
          });

          const geo = new THREE.PlaneGeometry(8, 8);
          const card = new THREE.Mesh(geo, mat);
          scene.add(card);
          // cards.push(card);

          video.play(); // ‚ö° come√ßa a tocar


        });

        // continue;



        // // cria textura a partir do v√≠deo
        // const videoTexture = new THREE.VideoTexture(video);
        // videoTexture.minFilter = THREE.LinearFilter;
        // videoTexture.magFilter = THREE.LinearFilter;
        // videoTexture.format = THREE.RGBFormat;

        // // taka o texto
        // const size = 512;
        // const canvas = document.createElement('canvas');
        // const ctx = canvas.getContext('2d');
        // ctx.fillStyle = 'rgba(0,0,0,0.4)';
        // ctx.fillRect(0, 0, size, size);
        // ctx.fillStyle = '#00e5ff';
        // ctx.font = 'bold 48px Arial';
        // ctx.textAlign = 'center';
        // ctx.textBaseline = 'middle';
        // ctx.fillText(`Card ${i + 1}`, size / 2, size / 2);
        // videoTexture.needsUpdate = true;

        // // cria o card com o v√≠deo
        // const geometry = new THREE.PlaneGeometry(6, 4);
        // const material = new THREE.MeshStandardMaterial({
        //   map: videoTexture,
        //   side: THREE.DoubleSide
        // });

        // const videoCard = new THREE.Mesh(geometry, material);
        // scene.add(videoCard);
        // cards.push(videoCard);
        // videoCard.position.z = -5;
      } else {
        const geo = new THREE.PlaneGeometry(8, 8);

        // üëâ Aqui √© onde chama a fun√ß√£o
        const texture = makeCardTexture(textCard[i], images[i]);
        const mat = new THREE.MeshStandardMaterial({
          map: texture,
          side: THREE.DoubleSide,
          roughness: 0.4,
          metalness: 0.1,
          transparent: true,
          opacity: 1,
          name: `card${i + 1}`
        });
        const card = new THREE.Mesh(geo, mat);
        cards.push(card);
        scene.add(card);
      }
    }

    pri(cards);

    var scroller = 0;
    var t = 0;
    var loop = 0;
    var loopLastChange = 0;
    var lastT = 0, t = 0;
    var timeToChange = 100;

    // --- Atualiza√ß√£o com base no scroll ---
    function updateCards(scrollPos) {
      // return;
      lastT = t;
      const altY = 1250, divScrollPos = 0.001, divScroller = 0.002;
      t = (altY + scrollPos) * divScrollPos + scroller * altY * divScroller; // controle de rota√ß√£o
      if (t != lastT) {
        loopLastChange = loop;
      }
      const radius = 5;
      const spacing = 0;
      const difY = 15;
      const coe = 1 / 2;

      var appr = 0;
      for (let i = 0; i < cards.length; i++) {
        const card = cards[i];
        const progress = t - i * Math.PI / 2 + 3; // controla quando cada card come√ßa
        const visible = true;
        const angle = -i * Math.PI * coe + t;// gira conforme o scroll
        const y = progress * Math.PI - i * spacing; // sobe suavemente
        card.rotation.y = Math.PI;
        card.scale.x = -1;

        if (visible) {
          // card.material.opacity = Math.min(1, progress); // aparece gradualmente
          card.position.set(Math.cos(angle) * radius, y - difY, Math.sin(angle) * radius);
          card.lookAt(0, y - difY, 0);
          card.material.opacity = 1;
        }
        appr++;
      }
      pri(appr);
      console.log(scrollPos, t, loopLastChange, loop - loopLastChange >= timeToChange);
      loop++;
      if (loop % 60 == 0 && false) {
        if (loop - loopLastChange >= timeToChange) {
          var gaps = [3684];
          var adding = 2500;
          for (var i = 0; i <= total - 1; i++) {
            gaps[i + 1] = gaps[i] + adding;
          }
          const dif = 650;
          for (var gap of gaps) {
            if (Math.abs(gap - scrollPos) <= dif) {
              console.log(gap);
              scroller = (t - (altY + gap) * divScrollPos) / (altY * divScroller);
              console.log((altY + scrollPos) * divScrollPos + scroller * altY * divScroller);
              break;
            }
          }
        }
      }
    }

    // --- Mouse parallax ---
    const mouse = { x: 0, y: 0 };
    window.addEventListener('mousemove', (e) => {
      mouse.x = (e.clientX / innerWidth - 0.5) * 2;
      mouse.y = (e.clientY / innerHeight - 0.5) * 2;
    });


    function attP(tecla) {
      if (tecla == 'w') {
        scroller -= 1;
      } else if (tecla == 's') {
        scroller += 1;
      }

    }

    window.addEventListener('keydown', (event) => {
      const tecla = event.key; // pega a tecla pressionada
      if (/^[a-zA-Z]$/.test(tecla)) { // verifica se √© letra
        attP(tecla);
      }
    });

    // --- Anima√ß√£o ---
    function animate() {
      requestAnimationFrame(animate);
      const scroll = window.scrollY;
      if (videoTexture && video.readyState >= video.HAVE_CURRENT_DATA) {
        videoTexture.needsUpdate = true;
      }
      updateCards(scroll);

      // Parallax suave
      // camera.position.x += (mouse.x * 2 - camera.position.x) * 0.05;
      // camera.position.y += (-mouse.y * 2 - camera.position.y) * 0.05;
      // camera.lookAt(0, 0, 0);

      renderer.render(scene, camera);
    }
    animate();

    // --- Resize ---
    window.addEventListener('resize', () => {
      // camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // image & text
    // --- Fun√ß√£o para gerar textura com imagem + texto ---
    // --- Fun√ß√£o para gerar textura com imagem + texto (corrigida) ---
    function makeCardTexture(text, imageURL) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const size = 512;
      canvas.width = size;
      canvas.height = size;

      // Carrega a imagem com THREE.TextureLoader
      const loader = new THREE.TextureLoader();
      const texture = new THREE.CanvasTexture(canvas);

      loader.load(
        imageURL,
        (imageTex) => {
          const img = imageTex.image;
          ctx.drawImage(img, 0, 0, size, size);

          // Sobreposi√ß√£o escura pra legibilidade
          ctx.fillStyle = 'rgba(0,0,0,0.4)';
          ctx.fillRect(0, 0, size, size);

          // Texto centralizado 
          ctx.fillStyle = '#00e5ff';
          ctx.font = 'bold 36px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(text[0], size / 2, size / 2 - 50);
          ctx.font = 'bold 24px Arial';
          ctx.fillText(text[1], size / 2, size / 2);
          ctx.fillText(text[2], size / 2, size / 2 + 30);

          texture.needsUpdate = true; // üîπ for√ßa atualiza√ß√£o no WebGL
        },
        undefined,
        (err) => console.error('Erro ao carregar imagem:', imageURL, err)
      );

      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      return texture;
    }


    function pri(item) {
      console.log(JSON.parse(JSON.stringify(item)))
    }

  </script>
</head>

<body>
  <header>
    <h1>Frase impactante</h1>
    <p>
      Texto ultra impactante
    </p>
  </header>

  <div id="spiral"></div>
  <div class="ui">


    <section class="container">
      <div class="box">
        <h2>üè¨ +20</h2>
        <p>Empresas atendidas com solu√ß√µes personalizadas</p>
      </div>
      <div class="box">
        <h2>ü§ù 15</h2>
        <p>Servi√ßos de alto impacto no mercado</p>
      </div>
      <div class="box">
        <h2>üíµ +25 milh√µes</h2>
        <p>Em projetos executados com nossos parceiros</p>
      </div>
      <div class="box">
        <h2>üßæ +50</h2>
        <p>Projetos estrat√©gicos com o setor privado</p>
      </div>
      <div class="box">
        <h2>üìú +65</h2>
        <p>Certificados emitidos com excel√™ncia t√©cnica</p>
      </div>
    </section>


    <!-- page02 -->
    <h2 style="text-align: center; color: #333; font-weight: 700; margin-bottom: 5px;">
      üî¨ Resultados Acad√™micos
    </h2>
    <p style="text-align: center; color: #777; margin-bottom: 40px;">
      *Os dados apresentados compreendem o per√≠odo entre 2019 e 2024
    </p>

    <div style="display: flex; justify-content: center;">
      <div class="cemtec-grid">

        <!-- Linha 1 -->
        <!-- <div class="item-info">
      <h2>ü§ù +5</h2>
      <p>Acordos de Confidencialidade (NDA)</p>
    </div> -->
        <div class="line-grid">
          <div class="item-info">
            <h2>üìÑ +30</h2>
            <p>Artigos Cient√≠ficos</p>
          </div>
          <div class="item-info">
            <h2>üåê +35</h2>
            <p>Partcipa√ß√µes em congressos</p>
          </div>
          <div class="item-info">
            <h2>üìò 19</h2>
            <p>Disserta√ß√µes conclu√≠das</p>
          </div>
        </div>

        <div class="line-grid">
          <div class="item-info">
            <h2>üß™ 9</h2>
            <p>Exames de Qualifica√ß√£o</p>
          </div>
          <div class="item-info">
            <h2>üì® +50</h2>
            <p>Manifesta√ß√µes do Setor Produtivo</p>
          </div>
          <div class="item-info">
            <h2>üí° 8</h2>
            <p>Patentes</p>
          </div>
        </div>

        <div class="line-grid">
          <div class="item-info">
            <h2>üéì 23</h2>
            <p>Trabalhos de Conclus√£o de Curso</p>
          </div>
          <div class="item-info">
            <h2>üìù 10</h2>
            <p>Relat√≥rios de Ensaio</p>
          </div>
          <div class="item-info">
            <h2>üß† 8</h2>
            <p>Teses</p>
          </div>
        </div>
        <div class="line-grid">
          <div class="item-info">
            <h2>üèõÔ∏è +120</h2>
            <p>Atividades Internas</p>
          </div>
          <div class="item-info">
            <h2>üåç +150</h2>
            <p>Atividades Externas</p>
          </div>
        </div>
      </div>
    </div>

    <hr style="margin-top: 50px; margin-bottom: 40px; border: none; border-top: 2px solid #ccc;">

    <!-- slider -->
    <button onclick="window.location.href='slider/index.html'">slider</button>
    <footer>
      *Dados referentes ao per√≠odo de 2019 a 2024
    </footer>
  </div>
</body>

</html>